package com.smartsparrow.eval.service;

import static com.smartsparrow.courseware.data.CoursewareElementType.INTERACTIVE;
import static com.smartsparrow.eval.action.Action.Type.CHANGE_PROGRESS;
import static com.smartsparrow.eval.action.progress.ProgressionType.ACTIVITY_REPEAT;
import static com.smartsparrow.eval.action.progress.ProgressionType.INTERACTIVE_REPEAT;
import static com.smartsparrow.util.Warrants.affirmArgument;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.inject.Inject;
import javax.inject.Singleton;

import com.google.common.collect.Lists;
import com.newrelic.api.agent.Trace;
import com.smartsparrow.courseware.data.CoursewareElement;
import com.smartsparrow.courseware.pathway.LearnerPathway;
import com.smartsparrow.eval.action.Action;
import com.smartsparrow.eval.action.ActionResolver;
import com.smartsparrow.eval.action.progress.ProgressAction;
import com.smartsparrow.eval.action.progress.ProgressActionContext;
import com.smartsparrow.eval.action.progress.ProgressionType;
import com.smartsparrow.eval.data.LearnerEvaluationResponseContext;
import com.smartsparrow.eval.data.ScenarioEvaluationResult;
import com.smartsparrow.eval.data.WalkableEvaluationResult;
import com.smartsparrow.eval.deserializer.ActionDeserializer;
import com.smartsparrow.learner.data.EvaluationActionState;
import com.smartsparrow.learner.data.LearnerWalkable;
import com.smartsparrow.learner.service.LearnerPathwayService;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Singleton
public class LearnerScenarioActionEnricher {

    private final LearnerPathwayService learnerPathwayService;
    private final ActionDeserializer actionDeserializer;
    private final ActionResolver actionResolver;

    @Inject
    public LearnerScenarioActionEnricher(final LearnerPathwayService learnerPathwayService,
                                         final ActionDeserializer actionDeserializer,
                                         final ActionResolver actionResolver) {
        this.learnerPathwayService = learnerPathwayService;
        this.actionDeserializer = actionDeserializer;
        this.actionResolver = actionResolver;
    }

    /**
     * Enriches the supplied response context with deserialized and resolved triggered actions. This step is
     * necessary to prepare for the action consumers.
     * When there are no scenario evaluation results then a default action is generated by the evaluated walkable
     * parent pathway. This pathway is saved to the context for later use.
     *
     * @param responseContext the response context to enrich
     * @return a mono with the action enriched response context
     */
    @Trace(async = true)
    public Mono<LearnerEvaluationResponseContext> enrich(final LearnerEvaluationResponseContext responseContext) {
        affirmArgument(responseContext != null, "responseContext is required");

        final List<ScenarioEvaluationResult> scenarioEvaluationResults = responseContext.getResponse()
                .getScenarioEvaluationResults();


        // if there are no scenario evaluation results, get the default action and return
        if (scenarioEvaluationResults.isEmpty()) {
            return enrichWithDefaultPathwayProgressionAction(responseContext);
        }

        return scenarioEvaluationResults.parallelStream()
                // we want to deserialize actions only for those scenarios that evaluated to true
                .filter(ScenarioEvaluationResult::getEvaluationResult)
                // deserialize all the actions for each scenario evaluation result
                .map(scenarioEvaluationResult -> actionDeserializer.deserialize(scenarioEvaluationResult.getActions()))
                // combined all the actions in a single list
                .reduce((accumulator, combiner) -> {
                    accumulator.addAll(combiner);
                    return accumulator;
                })
                .orElse(new ArrayList<>())
                .parallelStream()
                // resolve each deserialized action and flux it
                .map(action -> actionResolver.resolve(action, responseContext).flux())
                // concat all resolved actions in a single flux
                .reduce(Flux::concat)
                // return an empty flux when there are no actions
                .orElse(Flux.empty())
                .collectList()
                // if there is more than 1 CHANGE_PROGRESS action, keep only the first-one in the list
                .map(actions -> Stream.concat(
                        actions.stream()
                                .filter(action -> action.getType() == CHANGE_PROGRESS)
                                .limit(1),
                        actions.stream()
                                .filter(action -> action.getType() != CHANGE_PROGRESS))
                        .collect(Collectors.toList()))
                .flatMap(actions -> {
                    // if at this stage we still have no actions or no progression action
                    // then it means that no scenario evaluated to true
                    // therefore we need to inject a repeat action
                    if (actions.isEmpty() || getProgressAction(actions) == null) {
                        final LearnerWalkable walkable = responseContext.getResponse()
                                .getEvaluationRequest()
                                .getLearnerWalkable();

                        ProgressionType progressionType = walkable.getElementType().equals(INTERACTIVE) ? INTERACTIVE_REPEAT : ACTIVITY_REPEAT;
                        actions.add(new ProgressAction()
                                .setType(Action.Type.CHANGE_PROGRESS)
                                .setContext(new ProgressActionContext()
                                        .setProgressionType(progressionType)));
                    }

                    // else we are good just return the actions
                    return Mono.just(actions);
                })
                // if the triggered actions haven't been set yet then set them!
                .map(actions -> {
                    // set the deserialized, resolved triggered action to the response context
                    final WalkableEvaluationResult result = responseContext.getResponse()
                            .getWalkableEvaluationResult();

                    if (result.getTriggeredActions().isEmpty()) {
                        result.setTriggeredActions(actions);
                    }
                    return responseContext;
                })
                // all is left to do is to set the EvaluationActionState
                .map(enrichedResponseContext -> {
                    final LearnerWalkable walkable = enrichedResponseContext.getResponse()
                            .getEvaluationRequest()
                            .getLearnerWalkable();

                    EvaluationActionState state = new EvaluationActionState()
                            .setCoursewareElement(CoursewareElement.from(walkable.getId(), walkable.getElementType()))
                            .setProgressActionContext(getProgressAction(enrichedResponseContext.getResponse().getWalkableEvaluationResult().getTriggeredActions()).getContext());

                    enrichedResponseContext.setEvaluationActionState(state);
                    return enrichedResponseContext;
                });
    }

    /**
     * Fetch the LearnerPathway parent of the evaluated walkable to get the default progression action. The learner
     * pathway is set to the context for later use. The generated default action is added to the triggered action
     * in the context.
     *
     * @param responseContext the context to enrich
     * @return a mono including the action enriched evaluation response context
     */
    private Mono<LearnerEvaluationResponseContext> enrichWithDefaultPathwayProgressionAction(final LearnerEvaluationResponseContext responseContext) {
        final LearnerWalkable walkable = responseContext.getResponse()
                .getEvaluationRequest()
                .getLearnerWalkable();
        // find the pathway
        return getParentPathway(responseContext)
                .map(learnerPathway -> {
                    // set the pathway to the context
                    responseContext.setParentPathway(learnerPathway);
                    // set the default action
                    ProgressAction defaultProgressionAction = learnerPathway.getDefaultAction(walkable.getElementType());
                    responseContext.getResponse()
                            .getWalkableEvaluationResult()
                            .setTriggeredActions(Lists.newArrayList(defaultProgressionAction));
                    // set the evaluation state
                    responseContext.setEvaluationActionState(new EvaluationActionState()
                            .setCoursewareElement(CoursewareElement.from(walkable.getId(), walkable.getElementType()))
                            .setProgressActionContext(defaultProgressionAction.getContext()));
                    // nothing else to do, return the enriched context
                    return responseContext;
                });
    }

    /**
     * Find the evaluated walkable parent pathway
     *
     * @param responseContext the response context to access the walkable detail to find the parent pathway for
     * @return a mono containing the parent pathway
     */
    private Mono<LearnerPathway> getParentPathway(final LearnerEvaluationResponseContext responseContext) {
        final UUID pathwayId = responseContext.getResponse()
                .getEvaluationRequest()
                .getParentPathwayId();
        final LearnerWalkable walkable = responseContext.getResponse()
                .getEvaluationRequest()
                .getLearnerWalkable();

        return learnerPathwayService.find(pathwayId, walkable.getDeploymentId());
    }

    /**
     * Return the first action of type {@link Action.Type#CHANGE_PROGRESS} in the list
     *
     * @param actions the list to extract the progression action from
     * @return either the progression action or null when not found
     */
    @SuppressWarnings("rawtypes")
    private ProgressAction getProgressAction(List<Action> actions) {
        return (ProgressAction) actions.stream()
                .filter(action -> action.getType() == CHANGE_PROGRESS)
                .limit(1)
                .findFirst()
                .orElse(null);
    }
}
