var id = 0;

function genStrId() {
  id++;
  return id.toString();
}

function spreadOntoThis(thisObj, obj) {
  var props = Object.keys(obj);

  for (var i = 0; i < props.length; i++) {
    thisObj[props[i]] = obj[props[i]];
  }
}

var FetchMessage = function FetchMessage(message) {
  var fetchMessage = typeof message === 'string' ? { type: message } : message;
  this.id = genStrId();
  spreadOntoThis(this, fetchMessage);
};

FetchMessage.prototype.stringify = function stringify () {
  return JSON.stringify(this);
};

var HELLO = 'hello';
var SHUTDOWN = 'shutdown';

var AUTHENTICATE = 'authenticate';
var AUTHENTICATE_OK = 'authenticate.ok';
var AUTHENTICATE_ERROR = 'authenticate.error';

var IES_AUTHORIZE = 'ies.authorize';
var IES_AUTHORIZE_OK = 'ies.authorize.ok';
var IES_AUTHORIZE_ERROR = 'ies.authorize.error';

var MYCLOUD_AUTHORIZE = 'mycloud.authorize';
var MYCLOUD_AUTHORIZE_OK = 'mycloud.authorize.ok';
var MYCLOUD_AUTHORIZE_ERROR = 'mycloud.authorize.error';

var SUBSCRIBE = '.subscribe';
var SUBSCRIBE_OK = '.subscribe.ok';
var SUBSCRIBE_ERROR = '.subscribe.error';
var BROADCAST = '.broadcast';

function isMessageType(msg, type) {
  var msgType = msg.type;
  return msgType.indexOf(type, msgType.length - type.length) !== -1;
}

function setPrototypeOf(instance, thisObj) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(instance, Object.getPrototypeOf(thisObj));
  } else {
    instance.__proto__ = Object.getPrototypeOf(thisObj); // eslint-disable-line no-proto
  }
}

function captureStackTrace(instance, classFunc) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(instance, classFunc);
  }
}

function ConnectionFailedError(message) {
  var instance = new Error(message);
  setPrototypeOf(instance, this);
  captureStackTrace(instance, ConnectionFailedError);
  return instance;
}

function ConnectionClosedError(message) {
  var instance = new Error(message);
  setPrototypeOf(instance, this);
  captureStackTrace(instance, ConnectionClosedError);
  return instance;
}

function AuthenticationFailedError(message) {
  var instance = new Error(message);
  setPrototypeOf(instance, this);
  captureStackTrace(instance, AuthenticationFailedError);
  return instance;
}

function InvalidArgumentError(message) {
  var instance = new Error(message);
  setPrototypeOf(instance, this);
  captureStackTrace(instance, InvalidArgumentError);
  return instance;
}

var SHUTDOWN_MESSAGE = 'The Server has shut down the connection prematurely.';
var CONNECTION_CLOSED_MESSAGE = 'The connection was closed due to an unknown, possibly network, error.';
var CONNECTION_FAILED_MESSAGE = 'We were unable to establish a web socket connection.';

var ResponseMessage = function ResponseMessage(responseMessage) {
  spreadOntoThis(this, responseMessage);
  delete this.replyTo;
};

var BroadcastMessage = function BroadcastMessage(responseMessage) {
  spreadOntoThis(this, responseMessage);
  delete this.replyTo;
};

var FetchTracking = function FetchTracking(id, resolve, reject) {
  this.id = id;
  this.resolve = resolve;
  this.reject = reject;
};

var SubscribeTracking = function SubscribeTracking(subscriptionId, listener) {
  this.subscriptionId = subscriptionId;
  this.listener = listener;
};

var RequestTable = function RequestTable() {
  this._trackings = {};
  this._subscriptions = {};
};

RequestTable.prototype.track = function track (tracking) {
  this._add(tracking);
};

RequestTable.prototype.resolve = function resolve (trackingId, msg) {
  if (this._has(trackingId)) {
    var tracking = this._get(trackingId);
    this._resolveFetch(trackingId, tracking, msg);
  }
};

RequestTable.prototype.subscribe = function subscribe (tracking) {
  this._addSubscriptor(tracking);
};

RequestTable.prototype.unsubscribe = function unsubscribe (tracking) {
  this._removeSubscriptor(tracking);
};

RequestTable.prototype.clearSubscriptions = function clearSubscriptions () {
  this._subscriptions = {};
};

RequestTable.prototype.broadcast = function broadcast (subscriptionId, msg) {
    var this$1 = this;

  var subscriptions = this._subscriptions[subscriptionId];

  if (subscriptions && subscriptions.length) {
    subscriptions.forEach(function (subscription) {
      this$1._resolveSubscribe(subscription, msg);
    });
  }
};

RequestTable.prototype.isSubscribed = function isSubscribed (subscriptionId) {
  return !!this._subscriptions[subscriptionId];
};

RequestTable.prototype._resolveFetch = function _resolveFetch (trackingId, tracking, msg) {
  this._remove(trackingId);
  tracking.resolve(new ResponseMessage(msg));
};

/* eslint-disable class-methods-use-this */
RequestTable.prototype._resolveSubscribe = function _resolveSubscribe (tracking, msg) {
  tracking.listener(new BroadcastMessage(msg));
};
/* eslint-enable class-methods-use-this */

RequestTable.prototype._add = function _add (tracking) {
  if (!this._trackings[tracking.id]) {
    this._trackings[tracking.id] = tracking;
  }
};

RequestTable.prototype._get = function _get (trackingId) {
  return this._trackings[trackingId];
};

RequestTable.prototype._remove = function _remove (trackingId) {
  delete this._trackings[trackingId];
};

RequestTable.prototype._has = function _has (trackingId) {
  return !!this._trackings[trackingId];
};

RequestTable.prototype._addSubscriptor = function _addSubscriptor (tracking) {
  var subscriptionId = tracking.subscriptionId;

  if (this._subscriptions[subscriptionId]) {
    this._subscriptions[subscriptionId].push(tracking);
  } else {
    this._subscriptions[subscriptionId] = [tracking];
  }
};

RequestTable.prototype._removeSubscriptor = function _removeSubscriptor (tracking) {
  var subscriptionId = tracking.subscriptionId;

  if (this._subscriptions[subscriptionId]) {
    var subscriptorIndex = this._subscriptions[subscriptionId].indexOf(tracking);
    this._subscriptions[subscriptionId].splice(subscriptorIndex, 1);

    if (this._subscriptions[subscriptionId].length === 0) {
      delete this._subscriptions[subscriptionId];
    }
  }
};

var Subscription = function Subscription(ref) {
  var unsubscribeFunction = ref.unsubscribeFunction;

  this.unsubscribe = unsubscribeFunction;
};

var OPEN = 1;

var CLOSED = 3;

var MESSAGE = 'ping';

var HeartBeat = function HeartBeat(connection, timeBetweenBeats, timeAllowedPerBeat) {
  if ( timeBetweenBeats === void 0 ) timeBetweenBeats = 5000;
  if ( timeAllowedPerBeat === void 0 ) timeAllowedPerBeat = 4000;

  this._connection = connection;
  this._timeBetweenBeats = timeBetweenBeats;
  this._timePerBeat = timeAllowedPerBeat;

  this.beatCount = 0;
  this.beatStopped = true;

  this._handleBeatResponse = this._handleBeatResponse.bind(this);
  this._handleBeatMissing = this._handleBeatMissing.bind(this);
  this._beat = this._beat.bind(this);
};

HeartBeat.prototype.start = function start () {
  this.beatStopped = false;
  this._beat();
};

HeartBeat.prototype.stop = function stop () {
  this._resetBeatMissingTimeout();
  this.beatStopped = true;
};

HeartBeat.prototype.onStop = function onStop (stopCallback) {
  this._stopCallback = stopCallback;
};

HeartBeat.prototype._beat = function _beat () {
  if (!this._connection || this.beatStopped) {
    return;
  }

  // Set up race between 'server heartbeat' and 'missed beat' timout
  this._queueBeatResponse();
  // Set up tracker to track any missed beats. if any beats missed,
  // it means there is a connection issue and we need to trigger the close listeners
  this._queueBeatMissing();
};

HeartBeat.prototype._queueBeatResponse = function _queueBeatResponse () {
  this._connection.fetch(MESSAGE)
    .then(this._handleBeatResponse)
    .catch(this._handleBeatMissing);
};

HeartBeat.prototype._handleBeatResponse = function _handleBeatResponse () {
  this.beatCount += 1;
  // incase you dont get a beat back
  this._resetBeatMissingTimeout();
  this.stop();
};

HeartBeat.prototype._queueBeatMissing = function _queueBeatMissing () {
  this._beatMissingTimeoutId = setTimeout(this._handleBeatMissing, this._timePerBeat);
};

HeartBeat.prototype._handleBeatMissing = function _handleBeatMissing () {
  this.stop();

  if (this._stopCallback) {
    this._stopCallback();
  }
};

HeartBeat.prototype._resetBeatMissingTimeout = function _resetBeatMissingTimeout () {
  if (typeof this._beatMissingTimeoutId === 'number') {
    clearTimeout(this._beatMissingTimeoutId);
  }
};

var RtmConnection = function RtmConnection(options) {
  var socket = options.socket;
  var credentials = options.credentials;
  var url = options.url;
  var disableHeartBeat = options.disableHeartBeat;

  this._socket = socket;
  this._url = url;
  this._credentials = credentials;
  this._disableHeartBeat = disableHeartBeat;
  this._initialConnSuccessful = false;
  this._ready = false;
  this._resolveReady = function () { };
  this._rejectReady = function () { };
  this._requests = new RequestTable();
  this._bearerInfo = null;
  this._shutdown = false;
  this._closeListeners = [];
  this._openListeners = [];

  this._subscribeTracker = [];

  this._socket.onopen = this._onOpen.bind(this);
  this._socket.onclose = this._onClose.bind(this);
  this._socket.onerror = this._onError.bind(this);
  this._socket.onmessage = this._onMessage.bind(this);
};

//
// PUBLIC METHODS
//
RtmConnection.prototype.onReady = function onReady () {
    var this$1 = this;

  if (this._ready) {
    return Promise.resolve(this);
  }
  return new Promise(function (resolve, reject) {
    this$1._resolveReady = function () { return resolve(this$1); };
    this$1._rejectReady = function (err) { return reject(err); };
  });
};

RtmConnection.prototype.onClose = function onClose (listener) {
  this._closeListeners.push(listener);
};
RtmConnection.prototype.onOpen = function onOpen (listener) {
  this._openListeners.push(listener);
};

RtmConnection.prototype.getBearerInfo = function getBearerInfo () {
  return this._bearerInfo;
};

RtmConnection.prototype.fetch = function fetch (message) {
  if (this._shutdown) {
    // TODO when adding reconnection logic, queue these messages instead of rejecting
    return Promise.reject(new ConnectionClosedError(SHUTDOWN_MESSAGE));
  }

  var fetchMessage = new FetchMessage(message);
  return this._fetch(fetchMessage);
};

RtmConnection.prototype.subscribe = function subscribe (message, listener, replayed) {
    var this$1 = this;
    if ( replayed === void 0 ) replayed = false;

  // if these are replayed messages : Don't track
  // this flag will be true only when called from _replaySubscriptions
  if (!replayed) {
    var obj = {
      message: message,
      listener: listener,
    };
    this._subscribeTracker.push(obj);
  }
  if (this._shutdown) {
    // TODO when adding reconnection logic, queue these messages instead of rejecting
    return Promise.reject(new ConnectionClosedError(SHUTDOWN_MESSAGE));
  }

  var subscribeMessage = new FetchMessage(message);

  if (isMessageType(subscribeMessage, SUBSCRIBE)) {
    return new Promise(function (resolve, reject) {
      this$1._fetch(subscribeMessage)
        .then(function (subscribeResponse) {
          if (isMessageType(subscribeResponse, SUBSCRIBE_OK)) {
            resolve(this$1._trackSubscription(subscribeResponse.response.rtmSubscriptionId, listener));
          } else if (isMessageType(subscribeResponse, SUBSCRIBE_ERROR)) {
            reject(subscribeResponse.message);
          }
        })
        .catch(function (err) { return reject(err); });
    });
  }
  return Promise.reject(new InvalidArgumentError(((subscribeMessage.type) + " is not subscribable.")));
};

RtmConnection.prototype.close = function close () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  // trigger close listeners
  this._closeListeners.forEach(function (listener) { return listener(); });
  // if server disconnected - remove all subscriptions
  // Will replay all of them once new connection is established
  this._requests.clearSubscriptions();
  // clear heatbeat interval
  clearInterval(this._heartBeatInitiator);
  // terminate socket connection - this will trigger the _onClose event
  (ref = this._socket).close.apply(ref, args);
    var ref;
};

//
// DISPATCHERS (send message to server)
//
RtmConnection.prototype._fetch = function _fetch (fetchMessage) {
    var this$1 = this;

  if (this._socket.readyState !== OPEN) {
    // TODO when adding reconnection logic, queue these messages instead of rejecting
    return Promise.reject(new ConnectionClosedError(CONNECTION_CLOSED_MESSAGE));
  }

  return new Promise(function (resolve, reject) {
    var tracking = new FetchTracking(fetchMessage.id, resolve, reject);
    this$1._requests.track(tracking);
    this$1._socket.send(fetchMessage.stringify());
  });
};

//
// HELPERS
//
RtmConnection.prototype._makeUnsubscribeFunction = function _makeUnsubscribeFunction (tracking) {
    var this$1 = this;

  return function (unsubType) {
    this$1._requests.unsubscribe(tracking);
    var unsubMessage = new FetchMessage(unsubType);
    return this$1._fetch(unsubMessage);
  };
};

RtmConnection.prototype._trackSubscription = function _trackSubscription (subscriptionId, listener) {
  var tracking = new SubscribeTracking(subscriptionId, listener);
  this._requests.subscribe(tracking);

  return new Subscription({
    unsubscribeFunction: this._makeUnsubscribeFunction(tracking),
  });
};
/**
 * Websocket reconnection logic
 * _reconnect will be called from onClose event
 */
RtmConnection.prototype._reconnect = function _reconnect () {
    var this$1 = this;

  setTimeout(function () {
    // initiate new connection
    var socket = new WebSocket(this$1._url);
    // attach all the listeners back
    socket.onopen = this$1._socket.onopen;
    socket.onmessage = this$1._socket.onmessage;
    socket.onclose = this$1._socket.onclose;
    socket.onerror = this$1._socket.onerror;
    this$1._socket = socket;
    // https://sam-low.com/how-to-reopen-a-closed-websocket.html
  }, 5000);
};

// eslint-disable-next-line class-methods-use-this
RtmConnection.prototype._replaySubscriptions = function _replaySubscriptions () {
    var this$1 = this;

  if (this._subscribeTracker) {
    this._subscribeTracker.forEach(function (subscription) {
      this$1.subscribe(subscription.message, subscription.listener, true);
    });
  }
};
RtmConnection.prototype._startHeartBeat = function _startHeartBeat () {
    var this$1 = this;

  if (this._disableHeartBeat) {
    return;
  }
  if (!this._heartBeat) {
    this._heartBeat = new HeartBeat(this);
    this._heartBeat.onStop(function () { return this$1._handleShutdown.bind(this$1)(4002, 'Heartbeat timedout'); });
  }
  if (this._heartBeat.beatStopped) {
    this._heartBeat.start();
  }
};

//
// EVENT HANDLERS
//
RtmConnection.prototype._onOpen = function _onOpen (/* event */) {
  // double check if WS readystate is open - to handle browser network - client disconnect
  // websocket can still be in OPEN state
  if (this._socket.readyState === OPEN) {
    this._shutdown = false;
    this._openListeners.forEach(function (listener) { return listener(); });
    this._heartBeatInit();
  }
  this._initialConnSuccessful = true;
};

RtmConnection.prototype._onClose = function _onClose (event) {
  // make sure the connection is closed before reopening a new one
  if (this._socket.readyState === CLOSED) {
    // then try reconnecting
    this._reconnect();
  }
  if (!this._initialConnSuccessful) {
    var message = event ? (CONNECTION_FAILED_MESSAGE + "(" + (event.code) + ")") : CONNECTION_FAILED_MESSAGE;
    this._rejectReady(new ConnectionFailedError(message));
  }
};

RtmConnection.prototype._onError = function _onError (event) { // eslint-disable-line class-methods-use-this
  var message = event ? (CONNECTION_FAILED_MESSAGE + " (" + (event.code) + ")") : CONNECTION_FAILED_MESSAGE;
  this._rejectReady(new ConnectionFailedError(message));
};

RtmConnection.prototype._onMessage = function _onMessage (event) {
  try {
    // update _lastEventMsgTime with the most recent message received timestamp
    this._lastEventMsgTime = Date.now();
    var msg = JSON.parse(event.data);
    this._handleMessage(msg);
  } catch (e) { /* Swallow, nothing to be done if message cannot be parsed */ }
};

/**
 * Checks if the last message received from WS is greater than 30ms.
 * if yes - trigger heartbeat.
 */
RtmConnection.prototype._heartBeatInitaiatorTask = function _heartBeatInitaiatorTask () {
  var timeElapsed = Date.now() - this._lastEventMsgTime;
  if (timeElapsed > 29000) {
    this._startHeartBeat();
  }
};

/**
 * Runs the _heartBeatInitaiatorTask at an interval of 35s.
 */
RtmConnection.prototype._heartBeatInit = function _heartBeatInit () {
  this._heartBeatInitiator = setInterval(this._heartBeatInitaiatorTask.bind(this), 35000);
};

RtmConnection.prototype._handleMessage = function _handleMessage (msg) {
    var obj;

  var specialHandler = ( obj = {}, obj[HELLO] = this._handleHello.bind(this), obj[SHUTDOWN] = this._handleShutdown.bind(this), obj[AUTHENTICATE_OK] = this._handleAuthOk.bind(this), obj[AUTHENTICATE_ERROR] = this._handleAuthError.bind(this), obj[IES_AUTHORIZE_OK] = this._handleAuthOk.bind(this), obj[IES_AUTHORIZE_ERROR] = this._handleAuthError.bind(this), obj[MYCLOUD_AUTHORIZE_OK] = this._handleAuthOk.bind(this), obj[MYCLOUD_AUTHORIZE_ERROR] = this._handleAuthError.bind(this), obj)[msg.type];

  if (specialHandler) {
    specialHandler(msg);
  } else if (isMessageType(msg, BROADCAST)) {
    this._handleBroadcast(msg);
  } else if (msg.replyTo) {
    this._handleReplyTo(msg);
  }
};

RtmConnection.prototype._handleHello = function _handleHello (/* msg */) {
  var authenticateMessage;
  var ref = this._credentials;
    var bearerToken = ref.bearerToken;
    var email = ref.email;
    var password = ref.password;
    var pearsonUid = ref.pearsonUid;
    var pearsonToken = ref.pearsonToken;
    var myCloudToken = ref.myCloudToken;
  if (bearerToken) {
    authenticateMessage = new FetchMessage({ type: AUTHENTICATE, bearerToken: bearerToken });
  } else if (myCloudToken) {
    authenticateMessage = new FetchMessage({ type: MYCLOUD_AUTHORIZE, myCloudToken: myCloudToken });
  } else if (pearsonUid && pearsonToken) {
    authenticateMessage = new FetchMessage({ type: IES_AUTHORIZE, pearsonUid: pearsonUid, pearsonToken: pearsonToken });
  } else {
    authenticateMessage = new FetchMessage({ type: AUTHENTICATE, email: email, password: password });
  }
  this._socket.send(authenticateMessage.stringify());
};

RtmConnection.prototype._handleShutdown = function _handleShutdown () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

  (ref = this).close.apply(ref, args);
  this._shutdown = true;
    var ref;
};

RtmConnection.prototype._handleAuthOk = function _handleAuthOk (msg) {
  this._ready = true;
  this._bearerInfo = {
    bearerToken: msg.response.bearerToken,
    expiry: msg.response.expiry,
  };
  this._resolveReady();
  // rensend subscriptions once auth is OK.
  // we should make sure the subscriptions are played only after the reconnect and auth is succesful.
  this._replaySubscriptions();
};

RtmConnection.prototype._handleAuthError = function _handleAuthError (msg) {
  var error;
  if (msg.response && msg.response.reason) {
    error = new AuthenticationFailedError(msg.response.reason);
  } else if (msg.message) {
    error = new AuthenticationFailedError(msg.message);
  } else {
    error = new AuthenticationFailedError();
  }
  this._rejectReady(error);
  this.close();
};

RtmConnection.prototype._handleReplyTo = function _handleReplyTo (msg) {
  var requestId = msg.replyTo;
  this._requests.resolve(requestId, msg);
};

RtmConnection.prototype._handleBroadcast = function _handleBroadcast (msg) {
  var subscriptionId = msg.replyTo;
  this._requests.broadcast(subscriptionId, msg);
};

var open = function (url, credentials) {
  var socket = new WebSocket(url);
  var connection = new RtmConnection({
    socket: socket,
    credentials: credentials,
    url: url,
    disableHeartBeat: false,
  });
  return connection.onReady();
};

var rtm$1 = {
  open: open,
};

export { ConnectionFailedError, ConnectionClosedError, AuthenticationFailedError };
export default rtm$1;
